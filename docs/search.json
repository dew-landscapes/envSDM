[{"path":"https://acanthiza.github.io/envSDM/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Stuart Brown. Author. Nigel Willoughby. Author, maintainer. Joel Allan. Author.","code":""},{"path":"https://acanthiza.github.io/envSDM/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Brown S, Willoughby N, Allan J (2025). envSDM: Generate tuned spatially validated SDM's many taxa. R package version 0.2.0, https://dew-landscapes.github.io/envSDM/.","code":"@Manual{,   title = {envSDM: Generate tuned and spatially validated SDM's for many taxa},   author = {Stuart Brown and Nigel Willoughby and Joel Allan},   year = {2025},   note = {R package version 0.2.0},   url = {https://dew-landscapes.github.io/envSDM/}, }"},{"path":"https://acanthiza.github.io/envSDM/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generate tuned and spatially validated SDM's for many taxa","text":"envSDM CRAN. can install development version GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"dew-landscapes/envSDM\")"},{"path":[]},{"path":"https://acanthiza.github.io/envSDM/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 DEW Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/evaluate_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate an SDM — evaluate_sdm","title":"Evaluate an SDM — evaluate_sdm","text":"Returns various evaluation metrics predicts::pa_evaluate() flexsdm::sdm_eval().","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/evaluate_sdm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate an SDM — evaluate_sdm","text":"","code":"evaluate_sdm(m, p_test, b_test, do_gc = FALSE, ...)"},{"path":"https://acanthiza.github.io/envSDM/reference/evaluate_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate an SDM — evaluate_sdm","text":"m SDM result within tune_sdm() p_test Presence test data generated within tune_sdm() b_test Background test data generated within tune_sdm() do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful running SDMs many, many taxa, especially done parallel. Note, actually usees rm(list = ls(pattern = \"^[^e$]\")). ... Passed terra::predict() predicts::pa_evaluate()","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/evaluate_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate an SDM — evaluate_sdm","text":"paModelEvaluation (see predicts::pa_evaluate()) extra metrics flexsdm::sdm_eval(): AUC auc_po_flexsdm; BOYCE CBI; CBI_rescale (CBI -1 1, CBI_rescale 0 1); IMAE.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/evaluate_sdm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate an SDM — evaluate_sdm","text":"","code":"out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")    source(fs::path(out_dir, \"tune_sdm_ex.R\")) # make sure following prep file exists    prep <- rio::import(fs::path(out_dir, \"acaule\", \"prep.rds\")                       , trust = TRUE                       )    model <- tune_sdm(prep = prep                     , out_dir = FALSE                     , return_val = \"object\"                     , algo = \"rf\"                     , trees = 500                     , mtry = 2                     , nodesize = 1                     , keep_model = TRUE                     ) #> tuning acaule with algorithms: rf #> out_dir is C:/temp/nige\\RtmpSkBxRE\\file623c4cbd5588 #> rf tune #> tune rf ■■■                                5% |  ETA: 20s #> tune rf ■■■■                              11% |  ETA: 19s #> tune rf ■■■■■■                            16% |  ETA: 19s #> tune rf ■■■■■■■                           21% |  ETA: 19s #> tune rf ■■■■■■■■■                         26% |  ETA: 15s #> tune rf ■■■■■■■■■■                        32% |  ETA: 13s #> tune rf ■■■■■■■■■■■■                      37% |  ETA: 12s #> tune rf ■■■■■■■■■■■■■■                    42% |  ETA: 11s #> tune rf ■■■■■■■■■■■■■■■                   47% |  ETA:  9s #> tune rf ■■■■■■■■■■■■■■■■■                 53% |  ETA:  8s #> tune rf ■■■■■■■■■■■■■■■■■■                58% |  ETA:  7s #> tune rf ■■■■■■■■■■■■■■■■■■■■              63% |  ETA:  7s #> tune rf ■■■■■■■■■■■■■■■■■■■■■■            68% |  ETA:  6s #> tune rf ■■■■■■■■■■■■■■■■■■■■■■■           74% |  ETA:  5s #> tune rf ■■■■■■■■■■■■■■■■■■■■■■■■■         79% |  ETA:  4s #> tune rf ■■■■■■■■■■■■■■■■■■■■■■■■■■        84% |  ETA:  3s #> tune rf ■■■■■■■■■■■■■■■■■■■■■■■■■■■■      89% |  ETA:  2s #> tune rf ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■     95% |  ETA:  1s    presences <- prep$testing$testing[[1]][prep$testing$testing[[1]]$pa == 1, ]   background <- prep$testing$testing[[1]][prep$testing$testing[[1]]$pa == 0, ]    evaluate_sdm(model$tune_rf$m[[1]]                , p_test = presences                , b_test = background                ) #> @stats #>     np   na prevalence   auc   cor pcor  ODP auc_po auc_po_flexsdm   CBI #> 1 1065 5579       0.16 0.991 0.876    0 0.84  0.991          0.991 0.548 #>   CBI_rescale  IMAE #> 1       0.774 0.935 #>  #> @thresholds #>   max_kappa max_spec_sens no_omission equal_prevalence equal_sens_spec  or10 #> 1     0.258          0.14       0.004             0.16           0.198 0.272 #>  #> @tr_stats #>     treshold kappa  CCR  TPR  TNR  FPR  FNR  PPP  NPP  MCR  OR #> 1          0     0 0.16    1    0    1    0 0.16  NaN 0.84 NaN #> 2          0  0.23 0.57    1 0.48 0.52    0 0.27    1 0.43 Inf #> 3          0  0.29 0.63    1 0.56 0.44    0  0.3    1 0.37 Inf #> 4        ...   ...  ...  ...  ...  ...  ...  ...  ...  ... ... #> 243        1   0.6 0.91 0.47    1    0 0.53    1 0.91 0.09 Inf #> 244        1   0.6 0.91 0.47    1    0 0.53    1 0.91 0.09 Inf #> 245        1     0 0.84    0    1    0    1  NaN 0.84 0.16 NaN"},{"path":"https://acanthiza.github.io/envSDM/reference/fix_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Make sure all blocks achieve min_fold_n presences — fix_blocks","title":"Make sure all blocks achieve min_fold_n presences — fix_blocks","text":"Make sure blocks achieve min_fold_n presences","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/fix_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make sure all blocks achieve min_fold_n presences — fix_blocks","text":"","code":"fix_blocks(blocks, pres, min_fold_n = 8, pres_val = 1)"},{"path":"https://acanthiza.github.io/envSDM/reference/fix_blocks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make sure all blocks achieve min_fold_n presences — fix_blocks","text":"blocks Vector block ids pres Vector presence/absence data min_fold_n Minimum number presences block pres_val Value pres represent presence","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/fix_blocks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make sure all blocks achieve min_fold_n presences — fix_blocks","text":"Vector adjusted block ids ensuring block achieves min_fold_n presences","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/make_mcp.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum convex polygon around records — make_mcp","title":"Minimum convex polygon around records — make_mcp","text":"use predict boundary taxa, also see make_predict_boundary()","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/make_mcp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum convex polygon around records — make_mcp","text":"","code":"make_mcp(   presence,   out_file,   force_new = FALSE,   pres_x = \"long\",   pres_y = \"lat\",   in_crs = 4326,   out_crs = in_crs,   buf = 0,   clip = NULL )"},{"path":"https://acanthiza.github.io/envSDM/reference/make_mcp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum convex polygon around records — make_mcp","text":"presence Cleaned filtered dataframe presences out_file Character. Path mcp saved. saved sfarrow::st_write_parquet(). Currently work well full stop path. file types changed .parquet force_new Logical. out_file exists, recreate ? pres_x, pres_y Character. Name columns presence x y coordinates in_crs epsg code coordinates presence out_crs epsg code coordinates output mcp. Usually predictors buf Distance buffer mcp. Passed dist argument sf:st_buffer() units follow guidance. clip sf clip mcp","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/make_mcp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum convex polygon around records — make_mcp","text":"sf. out_file saved.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/make_mcp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimum convex polygon around records — make_mcp","text":"","code":"out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")  data <- file.path(system.file(package = \"predicts\"), \"ex\") |>   fs::dir_ls(regexp = \"\\\\.csv$\") |>   tibble::enframe(name = NULL, value = \"path\") |>   dplyr::mutate(taxa = gsub(\"\\\\.csv\", \"\", basename(path))                 , presence = purrr::map(path, rio::import, setclass = \"tibble\", trust = TRUE)                 , presence = purrr::map(presence                                         , \\(x) x |>                                           dplyr::filter(!is.na(lat)                                                         , !is.na(lon)                                           )                 )                 , out_dir = fs::path(out_dir, taxa)                 , out_mcp = fs::path(out_dir, \"mcp.parquet\")   )   # mcps --------  purrr::pwalk(list(data$presence                   , data$out_mcp ) , \\(x, y) make_mcp(x, y, pres_x = \"lon\") )"},{"path":"https://acanthiza.github.io/envSDM/reference/make_predict_boundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge polygons (or polygon files) to form a single minimum convex polygon (mcp) — make_predict_boundary","title":"Merge polygons (or polygon files) to form a single minimum convex polygon (mcp) — make_predict_boundary","text":"Primary use create predict boundary prep_sdm(), merging (existing) minimum convex polygon around points sources taxa distribution. Optionally, applying buffer around resulting mcp; clipping (usually coastal) boundary. predict boundary used generation background points masking 'full' predict (full extent environmental variables.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/make_predict_boundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge polygons (or polygon files) to form a single minimum convex polygon (mcp) — make_predict_boundary","text":"","code":"make_predict_boundary(   poly_list,   out_file,   buffer_metres = 0,   col_name = \"taxa\",   col_name_val = \"boundary\",   clip = NULL,   out_crs,   return_poly = FALSE,   force_new = FALSE )"},{"path":"https://acanthiza.github.io/envSDM/reference/make_predict_boundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge polygons (or polygon files) to form a single minimum convex polygon (mcp) — make_predict_boundary","text":"poly_list List paths list sf out_file Character name file save buffer_metres Numeric. Distance metres buffer mcp col_name Name column create resulting mcp col_name_val Value provide column resulting mcp clip sf. Clip resulting mcp back . out_crs Numeric. epsg code return_poly Logical. Return mcp, alternatively out_file force_new Logical. out_file exists, recreate ?","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/make_predict_boundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge polygons (or polygon files) to form a single minimum convex polygon (mcp) — make_predict_boundary","text":"return_poly, sf, else out_file. .parquet mcp written out_file","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/non_spatial_blocks.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate non spatial blocks — non_spatial_blocks","title":"Generate non spatial blocks — non_spatial_blocks","text":"Generate non spatial blocks","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/non_spatial_blocks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate non spatial blocks — non_spatial_blocks","text":"","code":"non_spatial_blocks(use_folds, data, pa_col = \"pa\", pres_val = 1)"},{"path":"https://acanthiza.github.io/envSDM/reference/non_spatial_blocks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate non spatial blocks — non_spatial_blocks","text":"use_folds Numeric. Total number folds data Dataframe pa_col pa_col Name column data containing p/values pres_val Value pa_col identifying presences","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://acanthiza.github.io/envSDM/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_preds.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate .png (map) files for each prediction — png_from_preds","title":"Generate .png (map) files for each prediction — png_from_preds","text":"Finds .tif files pred_dir writes .png files. Includes retrieval addition map : various SDM metrics; original presence points.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_preds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate .png (map) files for each prediction — png_from_preds","text":"","code":"png_from_preds(   pred_dir,   full_run_dir = NULL,   trim = TRUE,   force_new = FALSE,   do_gc = TRUE,   ... )"},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_preds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate .png (map) files for each prediction — png_from_preds","text":"trim Logical. Trim NA values outside (using terra::trim()) force_new Logical. .png file already exists, recreate ? do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful running SDMs many, many taxa, especially done parallel. ... Passed fs::dir_ls() prep Character named list. character, path existing prep.rds. Otherwise, result call prep_sdm() return_val = \"object\". full_run Character named list. character, path existing full_run.rds. Otherwise, result call run_full_sdm() return_val = \"object\". out_dir Character. Name directory .pngss saved. created exist.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_preds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate .png (map) files for each prediction — png_from_preds","text":"invisible(NULL). Writes .png files file name .tif files","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_preds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate .png (map) files for each prediction — png_from_preds","text":"","code":"# setup -------   out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")    env_dat <- system.file(\"ex/bio.tif\", package = \"predicts\")     # data ------   data <- fs::path(system.file(package = \"envSDM\"), \"examples\") |>     fs::dir_ls(regexp = \"prep\\\\.rds$\"                , recurse = TRUE                ) |>     tibble::enframe(name = NULL, value = \"prep\") |>     dplyr::mutate(taxa = gsub(\"\\\\.rds\", \"\", basename(dirname(prep)))                   , tune = gsub(\"prep\", \"tune\", prep)                   , out_dir = fs::path(out_dir, taxa, \"combo\")                   )    # Best combo--------   ## run full SDM --------   purrr::pmap(list(data$prep                     , data$tune                     , data$out_dir                     )                , \\(a, b, c) run_full_sdm(prep = a                                          , tune = b                                          , out_dir = c                                          , use_metric = \"combo\"                                           # passed to tune_sdm via dots                                          , metrics_df = envSDM::sdm_metrics                                          #, force_new = TRUE                                          )                ) #> [[1]] #> [[1]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/combo/full_run.rds #>  #>  #> [[2]] #> [[2]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/combo/full_run.rds #>  #>      ## predict -------   purrr::pwalk(list(data$prep                     , data$out_dir                     )                , \\(a, b) predict_sdm(prep = a                                      , full_run = fs::path(b, \"full_run.rds\")                                      , out_dir = b                                      , predictors = env_dat                                      , check_tifs = TRUE                                      #, force_new = TRUE                                      )                )    ## .pngs -------   if(FALSE) {      # not working for binary 'thresh' rasters (due to an issue with number of 'classes\"?):       # Error in if (any(na.omit(x) < min(breaks)) && show.warnings) warning(\"Values have found that are less than the lowest break\",  :       # missing value where TRUE/FALSE needed     purrr::walk2(data$out_dir                  , data$out_dir                  , \\(x, y) png_from_preds(pred_dir = x                                           , tune_dir = y                                           , trim = FALSE                                           , recurse = 1                                           )                  )    }    ## visualise-------   ### mask -------   purrr::walk(data$out_dir               , \\(x) fs::path(x, \"pred.tif\") %>%                 terra::rast() %>%                 terra::trim() %>%                 terra::plot()               )      # Best auc--------   ## run full SDM --------   data <- data %>%     dplyr::mutate(out_dir = gsub(\"combo\", \"auc_po\", out_dir))    purrr::pmap(list(data$prep                     , data$tune                     , data$out_dir                     )                , \\(a, b, c) run_full_sdm(prep = a                                          , tune = b                                          , out_dir = c                                          , use_metric = \"auc_po\"                                           # passed to tune_sdm via dots                                          , metrics_df = envSDM::sdm_metrics                                          #, force_new = TRUE                                          )               ) #> [[1]] #> [[1]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/auc_po/full_run.rds #>  #>  #> [[2]] #> [[2]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/auc_po/full_run.rds #>  #>     ## predict -------   purrr::pwalk(list(data$prep                     , data$out_dir                     )                , \\(a, b) predict_sdm(prep = a                                      , full_run = fs::path(b, \"full_run.rds\")                                      , out_dir = b                                      , predictors = env_dat                                      , is_env_pred = FALSE                                      , check_tifs = TRUE                                      #, force_new = TRUE                                      )                )     ## visualise-------   ### mask -------   purrr::walk(data$out_dir               , \\(x) fs::path(x, \"pred.tif\") %>%                 terra::rast() %>%                 terra::trim() %>%                 terra::plot()               )"},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_tif.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a .png from a .tif — png_from_tif","title":"Create a .png from a .tif — png_from_tif","text":"Used within prep_sdm save png density raster presences","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_tif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a .png from a .tif — png_from_tif","text":"","code":"png_from_tif(   x,   title = NULL,   dots = NULL,   trim = TRUE,   out_png = NULL,   do_gc = FALSE )"},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_tif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a .png from a .tif — png_from_tif","text":"x spatRaster path .tif title Character. Title add .png dots sf. Usually presences. Added points. trim Logical. Run terra::trim() writing .png? out_png Character. Name .png file save. NULL file name terra::sources(x) file type .png do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful running SDMs many, many taxa, especially done parallel.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/png_from_tif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a .png from a .tif — png_from_tif","text":"invisible(NULL). out_png written.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/predict_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from SDM — predict_sdm","title":"Predict from SDM — predict_sdm","text":"resulting pred.tif masked boundary provided pred_limit argument prep_sdm; generated prep_sdm pred_limit, limit_buffer pred_clip arguments.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/predict_sdm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from SDM — predict_sdm","text":"","code":"predict_sdm(   prep,   full_run,   out_dir,   file_name = \"pred.tif\",   use_env_naming = FALSE,   predictors = NULL,   is_env_pred = FALSE,   terra_options = NULL,   doClamp = TRUE,   force_new = FALSE,   do_gc = FALSE,   check_tifs = FALSE,   ... )"},{"path":"https://acanthiza.github.io/envSDM/reference/predict_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from SDM — predict_sdm","text":"prep Character named list. character, path existing prep.rds. Otherwise, result call prep_sdm() return_val = \"object\". full_run Character named list. character, path existing full_run.rds. Otherwise, result call run_full_sdm() return_val = \"object\". out_dir Character. Name directory .tifs saved. created exist. file_name Character. Name give output prediction .tif. use_env_naming Logical. TRUE, is_env_pred TRUE, naming ignore file_name instead generate name matching name_env_tif() layer this_taxa prep start_date minimum available start_date predictors. pred appears this_taxa start_date. predictors Character. Vector paths predictor .tif files. is_env_pred Logical. naming directory files predictors follow pattern required envRaster::parse_env_tif()? terra_options Passed terra::terraOptions(). e.g. list(memfrac = 0.6) doClamp Passed terra::predict() (passes ... fun). Possibly orphaned older envSDM? force_new Logical. output files already exist, remade? do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful keep RAM use running SDMs many, many taxa, especially done parallel. check_tifs Logical. Check output .tif files error terra::rast() delete . Useful crash predict. ... Passed ... terra::mask() - last step envSDM::predict_sdm process. Used provide additional arguments terra::writeRaster.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/predict_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from SDM — predict_sdm","text":"Named list created .tif files, usually 'pred.tif' 'thresh.tif'. Output .tif(s) .log, written out_dir.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/predict_sdm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from SDM — predict_sdm","text":"","code":"# setup -------   out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")    env_dat <- system.file(\"ex/bio.tif\", package = \"predicts\")     # data ------   data <- fs::path(system.file(package = \"envSDM\"), \"examples\") |>     fs::dir_ls(regexp = \"prep\\\\.rds$\"                , recurse = TRUE                ) |>     tibble::enframe(name = NULL, value = \"prep\") |>     dplyr::mutate(taxa = gsub(\"\\\\.rds\", \"\", basename(dirname(prep)))                   , tune = gsub(\"prep\", \"tune\", prep)                   , out_dir = fs::path(out_dir, taxa, \"combo\")                   )    # Best combo--------   ## run full SDM --------   purrr::pmap(list(data$prep                     , data$tune                     , data$out_dir                     )                , \\(a, b, c) run_full_sdm(prep = a                                          , tune = b                                          , out_dir = c                                          , use_metric = \"combo\"                                           # passed to tune_sdm via dots                                          , metrics_df = envSDM::sdm_metrics                                          #, force_new = TRUE                                          )                ) #> [[1]] #> [[1]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/combo/full_run.rds #>  #>  #> [[2]] #> [[2]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/combo/full_run.rds #>  #>      ## predict -------   purrr::pwalk(list(data$prep                     , data$out_dir                     )                , \\(a, b) predict_sdm(prep = a                                      , full_run = fs::path(b, \"full_run.rds\")                                      , out_dir = b                                      , predictors = env_dat                                      , check_tifs = TRUE                                      #, force_new = TRUE                                      )                )    ## .pngs -------   if(FALSE) {      # not working for binary 'thresh' rasters (due to an issue with number of 'classes\"?):       # Error in if (any(na.omit(x) < min(breaks)) && show.warnings) warning(\"Values have found that are less than the lowest break\",  :       # missing value where TRUE/FALSE needed     purrr::walk2(data$out_dir                  , data$out_dir                  , \\(x, y) png_from_preds(pred_dir = x                                           , tune_dir = y                                           , trim = FALSE                                           , recurse = 1                                           )                  )    }    ## visualise-------   ### mask -------   purrr::walk(data$out_dir               , \\(x) fs::path(x, \"pred.tif\") %>%                 terra::rast() %>%                 terra::trim() %>%                 terra::plot()               )      # Best auc--------   ## run full SDM --------   data <- data %>%     dplyr::mutate(out_dir = gsub(\"combo\", \"auc_po\", out_dir))    purrr::pmap(list(data$prep                     , data$tune                     , data$out_dir                     )                , \\(a, b, c) run_full_sdm(prep = a                                          , tune = b                                          , out_dir = c                                          , use_metric = \"auc_po\"                                           # passed to tune_sdm via dots                                          , metrics_df = envSDM::sdm_metrics                                          #, force_new = TRUE                                          )               ) #> [[1]] #> [[1]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/auc_po/full_run.rds #>  #>  #> [[2]] #> [[2]]$full_run_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/auc_po/full_run.rds #>  #>     ## predict -------   purrr::pwalk(list(data$prep                     , data$out_dir                     )                , \\(a, b) predict_sdm(prep = a                                      , full_run = fs::path(b, \"full_run.rds\")                                      , out_dir = b                                      , predictors = env_dat                                      , is_env_pred = FALSE                                      , check_tifs = TRUE                                      #, force_new = TRUE                                      )                )     ## visualise-------   ### mask -------   purrr::walk(data$out_dir               , \\(x) fs::path(x, \"pred.tif\") %>%                 terra::rast() %>%                 terra::trim() %>%                 terra::plot()               )"},{"path":"https://acanthiza.github.io/envSDM/reference/prep_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare for running an SDM — prep_sdm","title":"Prepare for running an SDM — prep_sdm","text":"background sampling includes code based Geographic Information Systems stack exchange answer user Spacedman.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/prep_sdm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare for running an SDM — prep_sdm","text":"","code":"prep_sdm(   this_taxa = NULL,   out_dir = FALSE,   return_val = \"path\",   presence,   pres_col = \"pa\",   pres_val = 1,   pres_crs = 4326,   pres_x = \"long\",   pres_y = \"lat\",   pred_limit = TRUE,   limit_buffer = 0,   pred_clip = NULL,   predictors,   is_env_pred = TRUE,   terra_options = NULL,   cat_preds = NULL,   num_bg = 10000,   prop_abs = \"abs\",   many_p_prop = 2,   folds = 5,   spatial_folds = TRUE,   repeats = 1,   block_div = seq(3, by = 2, length.out = repeats),   min_fold_n = 8,   hold_prop = 0.3,   stretch_value = 10,   dens_res = 1000,   reduce_env_thresh_corr = 0.9,   reduce_env_quant_rf_imp = 0.2,   do_gc = FALSE,   force_new = FALSE )"},{"path":"https://acanthiza.github.io/envSDM/reference/prep_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare for running an SDM — prep_sdm","text":"this_taxa Character. Name taxa. used print messages. Ignored NULL out_dir FALSE character. FALSE result prep_sdm saved temporary folder. character, file 'prep.rds' created path defined out_dir. return_val Character: \"object\" \"path\". return named list. case \"path\" named list simply list(prep = out_dir). set \"object\" out_dir FALSE. presence Dataframe presences columns pres_x pres_y. pres_col Character. Name column presence defines presence (1) absence (0). Optional presence data supplied. pres_val Numeric. Values pres_col represent presences. Optional presence data supplied. pres_crs Anything return legitimate crs passed crs attribute sf::st_transform() sf::st_as_sf(). pres_x, pres_y Character. Name columns presence x y coordinates pred_limit Limit background points predictions? Can TRUE (use presence generate minimum convex polygon use limit. recommended points presence usually filtered accurate spatial reliability thus may missing large number legitimate records); FALSE (full extent predictors used); path existing .parquet use; sf object. limit_buffer Numeric. Apply buffer pred_limit. used pred_limit TRUE. Passed dist argument sf::st_buffer(). pred_clip sf. Optional sf clip pred_limit back (e.g. prevent prediction ocean). predictors Character. Vector paths predictor .tif files. is_env_pred Logical. naming directory files predictors follow pattern required envRaster::parse_env_tif()? terra_options Passed terra::terraOptions(). e.g. list(memfrac = 0.6) cat_preds Character. Vector predictor names character. num_bg Numeric. many background points? prop_abs Character. num_bg proportion (prop) number records presence absolute (abs) number? many_p_prop Numeric. Ensure number background points least many_p_prop * number presences. e.g. 5000 presences num_bg set 10000 many_p_prop 2, num_bg increased many_p_prop * nrow(presences) folds Numeric. many folds use cross validation? adjusted downwards number presences support folds * min_fold_n spatial_folds Logical. Use spatial folds? Even TRUE, can resort non-spatial cv presences per fold meet min_fold_n enough presences support one fold. repeats Numeric. Number repeated cross validations. block_div Numeric. square root predict area divided value passed block_dist argument blockCV::cv_spatial(). using repeated cross validation, block_div must length 1:repeats. min_fold_n Numeric. Sets minimum number presences, , default, minimum number presences required model. hold_prop Numeric. Proportion data held back training use validate final model. stretch_value Numeric. Stretch density raster value. dens_res NULL numeric. Resolution (metres) density raster. Set NULL use resolution predictors. reduce_env_thresh_corr Numeric. Threshold used flag highly correlated variables. Set 1 skip step. > 0, highly correlated low importance variables removed. case highly correlated pairs variables, one removed. reduce_env_quant_rf_imp Numeric. Bottom quantile importance values drop. do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful running SDMs many, many taxa, especially done parallel. force_new Logical. outputs already exist, remade?","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/prep_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare for running an SDM — prep_sdm","text":"return_val \"object\" named list. return_val \"path\" named list list(prep = out_dir). out_dir valid path, 'full result' (irrespective return_val) also saved fs::path(out_dir, \"prep.rds\"). 'full result' named list elements: log: log (rough) timings information process abandoned: Logical indicating sdm abandoned. abandoned TRUE, list elements may present presence_ras: tibble two columns ('x' 'y') representing unique cell centroids predictors presences supplied argument presence predict_boundary: sf used limit background points used predict_sdm() generate 'mask'ed output bg_points: sf cell centroids representing unique cell centroids background points blocks data.frame columns: pa: presence (1) absence/background (0) x y: cell centroids presence absence block: spatial block row belongs column values predictors x y spatial_folds_used: logical indicating spatial folds used. may differ spatial_folds argument provided prep_sdm() attempt use spatial folds failed meet desired folds min_fold_n correlated: list elements per envModel::reduce_env(), , reduce_env FALSE, list elements remove_env empty, env_var keep, contain names predictors.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/prep_sdm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare for running an SDM — prep_sdm","text":"memory issue, try adjusting terra_options /do_gc. help build density raster assigning background points, 'absence' data can supplied presence 0 values. e.g. bird, absence data might generated sites birds recorded this_taxa .","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/prep_sdm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare for running an SDM — prep_sdm","text":"","code":"out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")    data <- file.path(system.file(package = \"predicts\"), \"ex\") |>     fs::dir_ls(regexp = \"\\\\.csv$\") |>     tibble::enframe(name = NULL, value = \"path\") |>     dplyr::mutate(taxa = gsub(\"\\\\.csv\", \"\", basename(path))                   , presence = purrr::map(path, rio::import, setclass = \"tibble\", trust = TRUE)                   , presence = purrr::map(presence                                           , \\(x) x |>                                             dplyr::filter(!is.na(lat)                                                           , !is.na(lon)                                                           )                                           )                   , taxa_dir = fs::path(out_dir, taxa)                   , out_mcp = fs::path(taxa_dir, \"mcp.parquet\")                   )    env_dat <- system.file(\"ex/bio.tif\", package = \"predicts\")     # mcps --------    # make a clip boundary so mcps stay terrestrial   clip <- terra::as.polygons(terra::rast(env_dat)[[1]] > -Inf) |>     sf::st_as_sf()    purrr::pwalk(list(data$presence                    , data$out_mcp                    )               , \\(x, y) make_mcp(x, y, pres_x = \"lon\"                                  , clip = clip                                  )               )     # prep -----------   # use the just created mcps (this allows using, say, a different spatial reliability threshold for the mcps)    purrr::pwalk(list(data$taxa                     , data$taxa_dir                     , data$presence                     , data$out_mcp                     )                , function(a, b, c, d) prep_sdm(this_taxa = a                                                , out_dir = b                                                , presence = c                                                , pres_x = \"lon\"                                                , pres_y = \"lat\"                                                , predictors = env_dat                                                , is_env_pred = FALSE                                                , pred_limit = d                                                , limit_buffer = 10000                                                , folds = 5                                                , repeats = 5                                                , hold_prop = 0                                                , dens_res = 1000 # ignored as decimal degrees preds                                                , reduce_env_thresh_corr = 0.95                                                , reduce_env_quant_rf_imp = 0.2                                                #, force_new = TRUE                                                )                )    # example of 'prep'   prep <- rio::import(fs::path(data$taxa_dir[[2]], \"prep.rds\"), trust = TRUE)    names(prep) #>  [1] \"abandoned\"        \"finished\"         \"this_taxa\"        \"original\"         #>  [5] \"pa_ras\"           \"presence_ras\"     \"predict_boundary\" \"bg_points\"        #>  [9] \"env\"              \"testing\"          \"training\"         \"reduce_env\"       #> [13] \"log\"                 # env variables to remove prior to SDM   prep$reduce_env$remove #>  [1] \"bio1\"  \"bio8\"  \"block\" \"cell\"  \"id\"    \"lat\"   \"lon\"   \"pa\"    \"x\"     #> [10] \"y\"        # Density raster   dens_ras <- terra::rast(fs::path(data$taxa_dir[[2]], \"density.tif\")) %>%     terra::mask(clip) %>%     terra::classify(matrix(c(0, NA), ncol = 2))    if(require(\"tmap\")) {      m <-       tm_shape(clip) +       tm_borders() +       tm_shape(dens_ras) +       tm_raster(title = \"Background point density\"                 , breaks = c(0, 2, 4, 6, 8, 10)                 , drop.levels = TRUE                 , colorNA = NULL                 ) +       tm_legend(outside = TRUE) +       tm_compass() +       tm_scale_bar() +       tm_layout(main.title = paste0(\"Background point density for \",  prep$this_taxa))      m      presences <- prep$pa_ras |>       dplyr::filter(pa == 1) %>%       sf::st_as_sf(coords = c(\"x\", \"y\")                    , crs = 4326                    )      m +       tm_shape(presences) +         tm_dots(col = \"pa\"                 , palette = \"viridis\"                 )    } #> Loading required package: tmap #> Breaking News: tmap 3.x is retiring. Please test v4, e.g. with #> remotes::install_github('r-tmap/tmap') #> Scale bar set for latitude km and will be different at the top and bottom of the map.     # Background points   if(require(\"tmap\")) {      blocks <- prep$bg_points %>%       dplyr::inner_join(prep$training |>                          dplyr::select(rep, training) |>                          tidyr::unnest(cols = c(training))                        ) |>       dplyr::mutate(block = factor(block) # for map                     , rep = paste0(\"rep: \", rep)                     ) %>%       sf::st_as_sf(coords = c(\"x\", \"y\")                    , crs = sf::st_crs(terra::rast(env_dat[[1]]))                    )       tm_shape(clip) +       tm_borders() +       tm_shape(blocks) +       tm_dots(title = \"Background points\\n coloured by block\"               , col = \"block\"               ) +       tm_facets(by = \"rep\") +       tm_legend(outside = TRUE) +       tm_compass() +       tm_scale_bar() +       tm_layout(main.title = paste0(\"Background points for \",  prep$this_taxa))     } #> Joining with `by = join_by(x, y)` #> Scale bar set for latitude km and will be different at the top and bottom of the map. #> Scale bar set for latitude km and will be different at the top and bottom of the map. #> Scale bar set for latitude km and will be different at the top and bottom of the map. #> Scale bar set for latitude km and will be different at the top and bottom of the map. #> Scale bar set for latitude km and will be different at the top and bottom of the map."},{"path":"https://acanthiza.github.io/envSDM/reference/run_full_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Run an SDM using no cross validation and previously established tune arguments — run_full_sdm","title":"Run an SDM using no cross validation and previously established tune arguments — run_full_sdm","text":"Run SDM using cross validation previously established tune arguments","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/run_full_sdm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run an SDM using no cross validation and previously established tune arguments — run_full_sdm","text":"","code":"run_full_sdm(   prep,   tune,   out_dir,   return_val = \"path\",   use_metric = \"combo\",   force_new = FALSE,   do_gc = FALSE,   ... )"},{"path":"https://acanthiza.github.io/envSDM/reference/run_full_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run an SDM using no cross validation and previously established tune arguments — run_full_sdm","text":"prep Character named list. character, path existing prep.rds. Otherwise, result call prep_sdm return_val = \"object\" tune Character named list. character, path existing tune.rds. Otherwise, result call tune_sdm return_val = \"object\" out_dir FALSE character. FALSE result run_full_sdm() saved temporary folder. character, file 'tune.rds' created path defined out_dir. return_val Character: \"object\" \"path\". return named list. case \"path\" named list simply list(full_run = out_dir). set \"object\" out_dir FALSE. use_metric Character. metric use find 'best' tune arguments previous tuning results? Default combo, product auc_po, CBI_rescale IMAE. use_metric must combo used use_metrics argument tune_sdm(). force_new Logical. outputs already exist, remade? do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful running SDMs many, many taxa, especially done parallel. ... Passed tune_sdm()","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/run_full_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run an SDM using no cross validation and previously established tune arguments — run_full_sdm","text":"return_val \"object\" named list. return_val \"path\" named list list(prep = out_dir). out_dir valid path, 'full result' (irrespective return_val) also saved fs::path(out_dir, \"prep.rds\"). 'full result' named list elements:","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/run_full_sdm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run an SDM using no cross validation and previously established tune arguments — run_full_sdm","text":"","code":"inst/examples/predict_sdm_ex.R #> Error: object 'inst' not found"},{"path":"https://acanthiza.github.io/envSDM/reference/sdm_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Lookup for metrics relevant to evaluating SDMs — sdm_metrics","title":"Lookup for metrics relevant to evaluating SDMs — sdm_metrics","text":"Lookup metrics relevant evaluating SDMs","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/sdm_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lookup for metrics relevant to evaluating SDMs — sdm_metrics","text":"","code":"sdm_metrics"},{"path":"https://acanthiza.github.io/envSDM/reference/sdm_metrics.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Lookup for metrics relevant to evaluating SDMs — sdm_metrics","text":"data frame 18 rows 5 variables: metric Character. Short name metric used outputs high_good Logical. high values metric correlate good model? is_thresh Logical. metric dependent setting threshold? summary_mets Logical. metrics use summarising? within_mets Logical. Included compatibility envFunc::make_metric_df() across_mets Logical. Included compatibility envFunc::make_metric_df()","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/thresh_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Threshold a previously predicted SDM — thresh_sdm","title":"Threshold a previously predicted SDM — thresh_sdm","text":"Threshold previously predicted SDM","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/thresh_sdm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Threshold a previously predicted SDM — thresh_sdm","text":"","code":"thresh_sdm(   pred_file,   this_taxa = NULL,   threshold,   thresh_file = NULL,   terra_options = NULL,   force_new = FALSE,   do_gc = FALSE,   check_tifs = TRUE )"},{"path":"https://acanthiza.github.io/envSDM/reference/thresh_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Threshold a previously predicted SDM — thresh_sdm","text":"pred_file Character. File path predicted sdm threshold. this_taxa Character. left default NULL attempt made extract taxa name pred_file threshold Numeric. > 0 < 1. Threshold apply raster stored file pred_file. Often value available within result call tune_sdm(). e.g. mod <- rio::import(\"tune.rds\") mod$e[[1]]@thresholds$max_spec_sens thresh_file Character. Name give output threshold. left default NULL, thresh_file set gsub(\"pred\", \"thresh\", pred_file) terra_options Passed terra::terraOptions(). e.g. list(memfrac = 0.6) force_new Logical. output files already exist, remade? do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful keep RAM use running SDMs many, many taxa, especially done parallel. check_tifs Logical. Check output .tif files error terra::rast() delete . Useful crash pred_file.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/thresh_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Threshold a previously predicted SDM — thresh_sdm","text":"List. list(thresh = thresh_file) corresponding file written.","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/thresh_sdm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Threshold a previously predicted SDM — thresh_sdm","text":"","code":"# setup -------   out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")    # data ------   extract_thresh <- function(tune, metric, thresh_type = \"max_spec_sens\") {      tune |>       dplyr::filter(!!rlang::ensym(metric) == max(!!rlang::ensym(metric))) |>       dplyr::pull(!!rlang::ensym(thresh_type))    }    data <- fs::path(system.file(package = \"envSDM\"), \"examples\") |>     fs::dir_ls(regexp = \"pred\\\\.tif\"                , recurse = TRUE                ) |>     tibble::enframe(name = NULL, value = \"pred\") |>     dplyr::mutate(out_dir = dirname(pred)                   , taxa = basename(dirname(out_dir))                   , metric = basename(out_dir)                   , tune = fs::dir_ls(out_dir, regexp = \"full_run.rds\")                   , tune_mean = purrr::map(tune, \\(x) rio::import(x, trust = TRUE)$tune_mean |> dplyr::select(algo, tune_args, auc_po, combo, max_spec_sens))                   , thresh = purrr::map2_dbl(tune_mean                                              , metric                                              , extract_thresh                                              )                    )    ## thresh -------   purrr::pwalk(list(data$pred                     , data$thresh                     , data$taxa                     )                , \\(a, b, c) thresh_sdm(pred_file = a                                        , threshold = b                                        , this_taxa = c                                        , thresh_file = \"thresh.tif\"                                        #, force_new = TRUE                                        )                ) #> threshold file: C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/auc_po/thresh.tif already exists #> threshold file: C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/combo/thresh.tif already exists #> threshold file: C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/auc_po/thresh.tif already exists #> threshold file: C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/combo/thresh.tif already exists    ## visualise-------   ### threshold -------   purrr::walk(data$out_dir               , \\(x) fs::path(x, \"thresh.tif\") %>%                 terra::rast() %>%                 terra::trim() %>%                 terra::plot()               )"},{"path":"https://acanthiza.github.io/envSDM/reference/tune_sdm.html","id":null,"dir":"Reference","previous_headings":"","what":"Tune, and evaluate, species distribution models — tune_sdm","title":"Tune, and evaluate, species distribution models — tune_sdm","text":"Tune, evaluate, species distribution models","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/tune_sdm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tune, and evaluate, species distribution models — tune_sdm","text":"","code":"tune_sdm(   prep,   out_dir = FALSE,   return_val = \"path\",   algo = c(\"all\", \"maxnet\", \"envelope\", \"rf\"),   max_corr = list(maxnet = 0.7, envelope = 0.9, rf = 0.99),   fc = \"auto_feature\",   limit_p = FALSE,   rm = seq(1, 6, 0.5),   trees = c(999),   mtry = TRUE,   limit_spat_mtry = 4,   nodesize = c(1, 2),   keep_model = FALSE,   best_run = FALSE,   metrics_df = envSDM::sdm_metrics,   use_metrics = c(\"auc_po\", \"CBI_rescale\", \"IMAE\"),   do_gc = FALSE,   force_new = FALSE,   ... )"},{"path":"https://acanthiza.github.io/envSDM/reference/tune_sdm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tune, and evaluate, species distribution models — tune_sdm","text":"prep Character named list. character, path existing prep.rds. Otherwise, result call prep_sdm return_val = \"object\" out_dir FALSE character. FALSE result tune_sdm saved temporary folder. character, file 'tune.rds' created path defined out_dir. return_val Character: \"object\" \"path\". return named list. case \"path\" named list simply list(tune = out_dir). set \"object\" out_dir FALSE. algo Character. Name algorithm use. max_corr Named list. Names list elements must match algorithms used. pair predictor variables correlated max_corr one dropped using caret::findCorrelation(). fc Character. Used generate levels classes argument maxnet::maxnet() tuned. limit_p TRUE, FALSE number predictor variables limit use p classes argument used maxnet::maxnet(). Useful many predictor variables becomes unwieldy generate interactions predictors. rm Numeric. Used generate levels regmult argument maxnet::maxnet() tuned. trees Used generate levels ntree argument randomForest::randomForest() tuned. TRUE (tune default trees), FALSE (tune trees) numeric (trees values tune ). mtry Used generate levels mtry argument randomForest::randomForest() tuned. TRUE (tune sensible guesses mtry), FALSE (use default randomForest::randomForest() mtry) numeric (mtry values tune ). limit_spat_mtry Numeric. mtry TRUE using spatial cross validation, values mtry tune limited less equal limit_spat_mtry. nodesize Used generate levels nodesize argument randomForest::randomForest() tuned. TRUE (tune default nodesize), FALSE (use default randomForest::randomForest() nodesize) numeric (nodesize values tune ). keep_model Logical. TRUE model results appended list column returned tibble (column m) best_run Logical. TRUE alters behaviour tune_sdm() , well, tuning. :). Sets blocks value cross-validation. metrics_df Dataframe. Defines metrics use deciding 'good' SDMs. use_metrics Character. Vector values metrics_df$metric use finding 'best' model. do_gc Logical. Run base::rm(list = ls) base::gc() end function? Useful running SDMs many, many taxa, especially done parallel. force_new Logical. outputs already exist, remade? ... Passed evaluate_sdm(). e.g. thresholds use predicts::pa_evaluate() (tr argument, although used, values thresholds element pa_ModelEvaluation object returned predicts::pa_evaluate() limited values tr).","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/tune_sdm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tune, and evaluate, species distribution models — tune_sdm","text":"return_val \"object\" named list. return_val \"path\" named list list(prep = out_dir). out_dir valid path, 'full result' (irrespective return_val) also saved fs::path(out_dir, \"prep.rds\"). 'full result' named list elements:","code":""},{"path":"https://acanthiza.github.io/envSDM/reference/tune_sdm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tune, and evaluate, species distribution models — tune_sdm","text":"","code":"out_dir <- file.path(system.file(package = \"envSDM\"), \"examples\")    data <- fs::path(system.file(package = \"envSDM\"), \"examples\") |>     fs::dir_ls(regexp = \"prep\\\\.rds$\"                , recurse = TRUE                ) |>     tibble::enframe(name = NULL, value = \"prep\") |>     dplyr::mutate(taxa = gsub(\"\\\\.rds\", \"\", basename(dirname(prep)))                   , out_dir = fs::path(out_dir, taxa)                   )    purrr::map(data$out_dir               , \\(x) tune_sdm(prep = fs::path(x, \"prep.rds\")                               , out_dir = x                               , fc = \"lq\"                               , rm = c(2, 3)                               , trees = 500                               , mtry = c(1:3)                               , nodesize = c(1, 2, 3)                               , limit_p = 3                               , use_metrics = c(\"auc_po\", \"CBI_rescale\", \"IMAE\", \"or10\")                               #, force_new = TRUE                               )               ) #> [[1]] #> [[1]]$tune_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/acaule/tune.rds #>  #>  #> [[2]] #> [[2]]$tune_file #> C:/temp/nige/RtmpANeETH/temp_libpath5e9c233a4e2a/envSDM/examples/bradypus/tune.rds #>  #>     # which tune args were best for each taxa using 'combo'?   data %>%     dplyr::mutate(tune = fs::path(out_dir, \"tune.rds\")                   , tune = purrr::map(tune, rio::import, trust = TRUE)                   , tune_mean = purrr::map(tune, \"tune_mean\")                   ) %>%     tidyr::unnest(cols = c(tune_mean)) %>%     dplyr::filter(best) %>% # used 'combo' to determine 'best' as default in tune_sdm     dplyr::select(taxa, algo, tune_args, combo, auc_po, IMAE, CBI, max_spec_sens) #> # A tibble: 2 × 8 #>   taxa     algo   tune_args     combo auc_po  IMAE   CBI max_spec_sens #>   <chr>    <chr>  <chr>         <dbl>  <dbl> <dbl> <dbl>         <dbl> #> 1 acaule   maxnet fc: lq. rm: 3 0.223  0.928 0.839 0.821         0.281 #> 2 bradypus maxnet fc: lq. rm: 3 0.121  0.726 0.610 0.855         0.459    # or best tune args choosing on just auc_po?   data %>%     dplyr::mutate(tune = fs::path(out_dir, \"tune.rds\")                   , tune = purrr::map(tune, rio::import, trust = TRUE)                   , all = purrr::map(tune, \"tune_mean\")                   ) %>%     tidyr::unnest(cols = c(all)) %>%     dplyr::group_by(taxa) %>%     dplyr::filter(auc_po == max(auc_po)) %>%     dplyr::ungroup() %>%     dplyr::select(taxa, algo, tune_args, auc_po, IMAE, CBI, max_spec_sens) #> # A tibble: 2 × 7 #>   taxa     algo   tune_args             auc_po  IMAE   CBI max_spec_sens #>   <chr>    <chr>  <chr>                  <dbl> <dbl> <dbl>         <dbl> #> 1 acaule   rf     tr: 500. mt: 2. ns: 3  0.973 0.884 0.885         0.242 #> 2 bradypus maxnet fc: lq. rm: 3          0.726 0.610 0.855         0.459"}]
