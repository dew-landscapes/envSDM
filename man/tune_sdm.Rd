% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_sdm.R
\name{tune_sdm}
\alias{tune_sdm}
\title{Tune, and evaluate, species distribution models}
\usage{
tune_sdm(
  prep,
  out_dir = FALSE,
  return_val = "path",
  algo = c("all", "maxnet", "envelope", "rf"),
  max_corr = list(maxnet = 0.7, envelope = 0.9, rf = 0.99),
  fc = "auto_feature",
  limit_p = FALSE,
  rm = seq(1, 6, 0.5),
  trees = c(999),
  mtry = TRUE,
  limit_spat_mtry = 4,
  nodesize = c(1, 2),
  keep_model = FALSE,
  best_run = FALSE,
  metrics_df = envSDM::sdm_metrics,
  use_metrics = c("auc_po", "CBI_rescale", "IMAE"),
  do_gc = FALSE,
  force_new = FALSE,
  ...
)
}
\arguments{
\item{prep}{Character or named list. If character, the path to an existing
\code{prep.rds}. Otherwise, the result of a call to prep_sdm with return_val =
"object"}

\item{out_dir}{FALSE or character. If FALSE the result of tune_sdm will be
saved to a temporary folder. If character, a file 'tune.rds' will be created
at the path defined by out_dir.}

\item{return_val}{Character: "object" or "path". Both return a named list. In
the case of "path" the named list is simply list(tune = out_dir). Will be set
to "object" if \code{out_dir} is FALSE.}

\item{algo}{Character. Name of algorithm to use.}

\item{max_corr}{Named list. Names of list elements must match algorithms
being used. For each pair of predictor variables correlated at or above
\code{max_corr} one will be dropped using \code{caret::findCorrelation()}.}

\item{fc}{Character. Used to generate levels of \code{classes} argument to
\code{maxnet::maxnet()} that are tuned.}

\item{limit_p}{\code{TRUE}, \code{FALSE} or number of predictor variables above which
to limit the use of \code{p} in the classes argument used in \code{maxnet::maxnet()}.
Useful with many predictor variables when it becomes unwieldy to generate
interactions for all predictors.}

\item{rm}{Numeric. Used to generate levels of \code{regmult} argument to
\code{maxnet::maxnet()} that are tuned.}

\item{trees}{Used to generate the levels of \code{ntree} argument to
\code{randomForest::randomForest()} that are tuned. \code{TRUE} (tune with default
\code{trees}), \code{FALSE} (don't tune \code{trees}) or numeric (the \code{trees} values to tune
with).}

\item{mtry}{Used to generate the levels of \code{mtry} argument to
\code{randomForest::randomForest()} that are tuned. \code{TRUE} (tune with sensible guesses for
\code{mtry}), \code{FALSE} (only use default \code{randomForest::randomForest()} \code{mtry}) or
numeric (the \code{mtry} values to tune with).}

\item{limit_spat_mtry}{Numeric. If \code{mtry} is \code{TRUE} and if using spatial
cross validation, the values of \code{mtry} to tune will be limited to less than
or equal to \code{limit_spat_mtry}.}

\item{nodesize}{Used to generate the levels of \code{nodesize} argument to
\code{randomForest::randomForest()} that are tuned. \code{TRUE} (tune with default
\code{nodesize}), \code{FALSE} (only use default \code{randomForest::randomForest()}
\code{nodesize}) or numeric (the \code{nodesize} values to tune with).}

\item{keep_model}{Logical. If \code{TRUE} the model results will be appended as a
list column in the returned tibble (as column \code{m})}

\item{best_run}{Logical. If \code{TRUE} this alters the behaviour of the
\code{tune_sdm()} by, well, not tuning. :). Sets all blocks to the same value so
no cross-validation.}

\item{metrics_df}{Dataframe. Defines which metrics to use when deciding on
'good' SDMs.}

\item{use_metrics}{Character. Vector of values in metrics_df$metric to use
when finding the 'best' model.}

\item{do_gc}{Logical. Run \code{base::rm(list = ls)} and \code{base::gc()} at end of
function? Useful when running SDMs for many, many taxa, especially if done in
parallel.}

\item{force_new}{Logical. If outputs already exist, should they be remade?}

\item{...}{Passed to \code{evaluate_sdm()}. e.g. thresholds for use in
\code{predicts::pa_evaluate()} (as \code{tr} argument, although if used, the values of
the \code{thresholds} element of the \code{pa_ModelEvaluation} object returned by
\code{predicts::pa_evaluate()} will be limited to the values in \code{tr}).}
}
\value{
If \code{return_val} is "object" a named list. If \code{return_val} is "path"
a path to the saved file. If \code{out_dir} is a valid path, the 'full
result' (irrespective of \code{return_val}) is also saved to
\code{fs::path(out_dir, "prep.rds")}. The 'full result' is a named list with
elements:
}
\description{
Tune, and evaluate, species distribution models
}
\examples{

  out_dir <- file.path(system.file(package = "envSDM"), "examples")

  data <- fs::path(system.file(package = "envSDM"), "examples") |>
    fs::dir_ls(regexp = "prep\\\\.rds$"
               , recurse = TRUE
               ) |>
    tibble::enframe(name = NULL, value = "prep") |>
    dplyr::mutate(taxa = gsub("\\\\.rds", "", basename(dirname(prep)))
                  , out_dir = fs::path(out_dir, taxa)
                  )

  purrr::map(data$out_dir
              , \(x) tune_sdm(prep = fs::path(x, "prep.rds")
                              , out_dir = x
                              , fc = "lq"
                              , rm = c(2, 3)
                              , trees = 500
                              , mtry = c(1:3)
                              , nodesize = c(1, 2, 3)
                              , limit_p = 3
                              , use_metrics = c("auc_po", "CBI_rescale", "IMAE", "or10")
                              #, force_new = TRUE
                              )
              )

  # which tune args were best for each taxa using 'combo'?
  data \%>\%
    dplyr::mutate(tune = fs::path(out_dir, "tune.rds")
                  , tune = purrr::map(tune, rio::import, trust = TRUE)
                  , tune_mean = purrr::map(tune, "tune_mean")
                  ) \%>\%
    tidyr::unnest(cols = c(tune_mean)) \%>\%
    dplyr::filter(best) \%>\% # used 'combo' to determine 'best' as default in tune_sdm
    dplyr::select(taxa, algo, tune_args, combo, auc_po, IMAE, CBI, max_spec_sens)

  # or best tune args choosing on just auc_po?
  data \%>\%
    dplyr::mutate(tune = fs::path(out_dir, "tune.rds")
                  , tune = purrr::map(tune, rio::import, trust = TRUE)
                  , all = purrr::map(tune, "tune_mean")
                  ) \%>\%
    tidyr::unnest(cols = c(all)) \%>\%
    dplyr::group_by(taxa) \%>\%
    dplyr::filter(auc_po == max(auc_po)) \%>\%
    dplyr::ungroup() \%>\%
    dplyr::select(taxa, algo, tune_args, auc_po, IMAE, CBI, max_spec_sens)
}
