% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prep_sdm.R
\name{prep_sdm}
\alias{prep_sdm}
\title{Prepare for running an SDM}
\usage{
prep_sdm(
  this_taxa = NULL,
  out_dir = FALSE,
  return_val = "path",
  presence,
  pres_col = "pa",
  pres_val = 1,
  pres_crs = 4326,
  pres_x = "long",
  pres_y = "lat",
  pred_limit = TRUE,
  limit_buffer = 0,
  pred_clip = NULL,
  predictors,
  is_env_pred = TRUE,
  max_cells_in_memory = 3e+07,
  terra_options = NULL,
  cat_preds = NULL,
  num_bg = 10000,
  prop_abs = "abs",
  many_p_prop = 2,
  folds = 5,
  spatial_folds = TRUE,
  min_fold_n = 8,
  hold_prop = 0.3,
  stretch_value = 10,
  dens_res = 1000,
  reduce_env_thresh_corr = 0.9,
  reduce_env_quant_rf_imp = 0.2,
  do_gc = FALSE,
  force_new = FALSE
)
}
\arguments{
\item{this_taxa}{Character. Name of taxa. Only used to print some messages.
Ignored if NULL}

\item{out_dir}{FALSE or character. If FALSE the result of prep_sdm will be
saved to a temporary folder. If character, a file 'prep.rds' will be created
at the path defined by out_dir.}

\item{return_val}{Character: "object" or "path". Both return a named list. In
the case of "path" the named list is simply list(prep = out_dir). Will be set
to "object" if \code{out_dir} is FALSE.}

\item{presence}{Dataframe of presences with columns \code{pres_x} and \code{pres_y}.}

\item{pres_col}{Character. Name of column in \code{presence} that defines presence
(\code{1}) or absence (\code{0}). Optional if only presence data is supplied.}

\item{pres_val}{Numeric. Values in \code{pres_col} that represent presences.
Optional if only presence data is supplied.}

\item{pres_crs}{Anything that will return a legitimate crs when passed to the
crs attribute of \code{sf::st_transform()} or \code{sf::st_as_sf()}.}

\item{pres_x, pres_y}{Character. Name of the columns in \code{presence} that have
the x and y coordinates}

\item{pred_limit}{Limit the background points and predictions?
Can be \code{TRUE} (use \code{presence} to generate a minimum convex polygon to use as
a limit. Not recommended as the points in \code{presence} have usually been
filtered to very accurate spatial reliability and thus may be missing a large
number of legitimate records); \code{FALSE} (the full extent of the predictors
will be used); path to existing .parquet to use; or sf object.}

\item{limit_buffer}{Numeric. Apply this buffer to \code{pred_limit}. Only used if
\code{pred_limit} is \code{TRUE}. Passed to the \code{dist} argument of \code{sf::st_buffer()}.}

\item{pred_clip}{sf. Optional sf to clip the pred_limit back to (e.g. to
prevent prediction into ocean).}

\item{predictors}{Character. Vector of paths to predictor \code{.tif} files.}

\item{is_env_pred}{Logical. Does the naming of the directory and files in
\code{predictors} follow the pattern required by \code{envRaster::parse_env_tif()}?}

\item{max_cells_in_memory}{Numeric passed to \code{exactextractr::exactextract()}
argument with the same name. \code{prep_sdm()} will be quicker with larger values,
but if running on many cores, memory issues are likely. The default of
30000000 is the default for \code{exactextractr::exactextract()} at the time of
writing.}

\item{terra_options}{Passed to \code{terra::terraOptions()}. e.g. list(memfrac =
0.6)}

\item{cat_preds}{Character. Vector of predictor names that are character.}

\item{num_bg}{Numeric. How many background points?}

\item{prop_abs}{Character. Is \code{num_bg} a proportion (\code{prop}) of the number of
records in \code{presence} or an absolute (\code{abs}) number?}

\item{many_p_prop}{Numeric. Ensure the number of background points is at
least \verb{many_p_prop * number of presences}. e.g. If there are more than 5000
presences and num_bg is set at \code{10000} and \code{many_p_prop} is \code{2}, then num_bg
will be increased to \code{many_p_prop * nrow(presences)}}

\item{folds}{Numeric. How many folds to use in cross validation? Will be
adjusted downwards if number of presences do not support \code{folds * min_fold_n}}

\item{spatial_folds}{Logical. Use spatial folds? Even if \code{TRUE}, can resort
to non-spatial cv if presences per fold do not meet \code{min_fold_n} or there are
not enough presences to support more than one fold.}

\item{min_fold_n}{Numeric. Sets both minimum number of presences, and,
by default, the minimum number of presences required for a model.}

\item{hold_prop}{Numeric. Proportion of data to be held back from training
to use to validate the final model.}

\item{stretch_value}{Numeric. Stretch the density raster to this value.}

\item{dens_res}{\code{NULL} or numeric. Resolution (in metres) of density raster.
Set to \code{NULL} to use the same resolution as the predictors.}

\item{reduce_env_thresh_corr}{Numeric. Threshold used to flag highly
correlated variables. Set to 1 to skip this step. If > 0, highly
correlated and low importance variables will be removed. In the case of
highly correlated pairs of variables, only one is removed.}

\item{reduce_env_quant_rf_imp}{Numeric. Bottom quantile of importance values
to drop.}

\item{do_gc}{Logical. Run \code{base::rm(list = ls)} and \code{base::gc()} at end of
function? Useful when running SDMs for many, many taxa, especially if done in
parallel.}

\item{force_new}{Logical. If outputs already exist, should they be remade?}
}
\value{
If \code{return_val} is "object" a named list. If \code{return_val} is "path"
a named list \code{list(prep = out_dir)}. If \code{out_dir} is a valid path, the 'full
result' (irrespective of \code{return_val}) is also saved to
\code{fs::path(out_dir, "prep.rds")}. The 'full result' is a named list with
elements:
\itemize{
\item log:
\itemize{
\item a log of (rough) timings and other information from the process
}
\item abandoned:
\itemize{
\item Logical indicating if the sdm was abandoned. If abandoned is TRUE, some
list elements may not be present
}
\item presence_ras:
\itemize{
\item tibble with two columns ('x' and 'y') representing unique cell
centroids on the predictors at presences supplied in argument \code{presence}
}
\item predict_boundary:
\itemize{
\item sf used to limit the background points and used by \code{predict_sdm()} to
generate the 'mask'ed output
}
\item bg_points:
\itemize{
\item sf of cell centroids representing unique cell centroids for background
points
}
\item blocks
\itemize{
\item data.frame with columns:
\itemize{
\item \code{pa}: presence (1) or absence/background (0)
\item \code{x} and \code{y}: cell centroids for each presence and absence
\item \code{block}: the spatial block to which the row belongs
\item a column with values for each of \code{predictors} at \code{x} and \code{y}
}
}
\item spatial_folds_used:
\itemize{
\item logical indicating if spatial folds were used. This may differ from
the \code{spatial_folds} argument provided to \code{prep_sdm()} if an attempt to
use spatial folds failed to meet desired \code{folds} and \code{min_fold_n}
}
\item correlated:
\itemize{
\item list with elements as per \code{envModel::reduce_env()}, or, if
\code{reduce_env} is \code{FALSE}, a list with elements \code{remove_env} which is
empty, and \code{env_var} and \code{keep}, which both contain the names of all
predictors.
}
}
}
\description{
The background sampling includes code based on a
\href{https://gis.stackexchange.com/}{Geographic Information Systems stack exchange}
\href{https://gis.stackexchange.com/a/224347}{answer}
by user \href{https://gis.stackexchange.com/users/865/spacedman}{Spacedman}.
}
\details{
Options for managing memory are \code{terra_options}, \code{max_cells_in_memory} and
\code{do_gc}.

To help build the density raster for assigning background points, 'absence'
data can be supplied in \code{presence} as \code{0} values. e.g. For a bird, absence
data might be generated from other sites where birds were recorded but
\code{this_taxa} was not.
}
\examples{

  out_dir <- file.path(system.file(package = "envSDM"), "examples")

  data <- file.path(system.file(package = "predicts"), "ex") |>
    fs::dir_ls(regexp = "\\\\.csv$") |>
    tibble::enframe(name = NULL, value = "path") |>
    dplyr::mutate(taxa = gsub("\\\\.csv", "", basename(path))
                  , presence = purrr::map(path, rio::import, setclass = "tibble", trust = TRUE)
                  , presence = purrr::map(presence
                                          , \(x) x |>
                                            dplyr::filter(!is.na(lat)
                                                          , !is.na(lon)
                                                          )
                                          )
                  , taxa_dir = fs::path(out_dir, taxa)
                  , out_mcp = fs::path(taxa_dir, "mcp.parquet")
                  )

  env_dat <- system.file("ex/bio.tif", package = "predicts")


  # mcps --------

  # make a clip boundary so mcps stay terrestrial
  clip <- terra::as.polygons(terra::rast(env_dat)[[1]] > -Inf) |>
    sf::st_as_sf()

  purrr::pwalk(list(data$presence
                   , data$out_mcp
                   )
              , \(x, y) make_mcp(x, y, pres_x = "lon"
                                 , clip = clip
                                 )
              )


  # prep -----------
  # use the just created mcps (this allows using, say, a different spatial reliability threshold for the mcps)

  purrr::pwalk(list(data$taxa
                    , data$taxa_dir
                    , data$presence
                    , data$out_mcp
                    )
               , function(a, b, c, d) prep_sdm(this_taxa = a
                                               , out_dir = b
                                               , presence = c
                                               , pres_x = "lon"
                                               , pres_y = "lat"
                                               , predictors = env_dat
                                               , is_env_pred = FALSE
                                               , pred_limit = d
                                               , limit_buffer = 10000
                                               , dens_res = 1000 # ignored as decimal degrees preds
                                               , reduce_env_thresh_corr = 0.95
                                               , reduce_env_quant_rf_imp = 0.2
                                               #, force_new = TRUE
                                               )
               )

  # example of 'prep'
  prep <- rio::import(fs::path(data$taxa_dir[[2]], "prep.rds"), trust = TRUE)

  names(prep)

  # env variables to remove prior to SDM
  prep$reduce_env$remove

  # Density raster
  dens_ras <- terra::rast(fs::path(data$taxa_dir[[2]], "density.tif")) \%>\%
    terra::mask(clip) \%>\%
    terra::classify(matrix(c(0, NA), ncol = 2))

  if(require("tmap")) {

    m <-
      tm_shape(clip) +
      tm_borders() +
      tm_shape(dens_ras) +
      tm_raster(title = "Background point density"
                , breaks = c(0, 2, 4, 6, 8, 10)
                , drop.levels = TRUE
                , colorNA = NULL
                ) +
      tm_legend(outside = TRUE) +
      tm_compass() +
      tm_scale_bar() +
      tm_layout(main.title = paste0("Background point density for ",  prep$this_taxa))

    m

    presences <- prep$blocks \%>\%
      dplyr::filter(pa == 1) \%>\%
      sf::st_as_sf(coords = c("x", "y")
                   , crs = 4326
                   )

    m +
      tm_shape(presences) +
        tm_dots(col = "blue")

  }

  # Background points
  if(require("tmap")) {

    blocks <- prep$blocks \%>\%
      dplyr::mutate(blocks = factor(block)) \%>\% # for map
      sf::st_as_sf(coords = c("x", "y")
                   , crs = sf::st_crs(terra::rast(env_dat[[1]]))
                   )


    tm_shape(clip) +
      tm_borders() +
      tm_shape(blocks) +
      tm_dots(title = "Background points\n coloured by block"
              , col = "block"
              ) +
      tm_legend(outside = TRUE) +
      tm_compass() +
      tm_scale_bar() +
      tm_layout(main.title = paste0("Background points for ",  prep$this_taxa))


  }
}
